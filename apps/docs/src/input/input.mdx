import { Canvas, Meta, Source } from '@storybook/addon-docs/blocks'
import * as Input from './input.stories'

import mouse from "./mouse?raw"
import touch from "./touch?raw"
import controls from "./controls?raw"

<Meta of={Input} />

# Input

It's pretty easy to add input controls to your game. Let's have a look.

## Mouse

The `mouse()` behavior provides mouse support for your game. It automatically detects movement and clicks.

When you click on an entity, it will trigger an `entityClick` event with the entity's ID. If you click on an empty area of the scene, a `sceneClick` event is triggered with the position of the click. Mouse movement will continuously update the `mouse` entity's position.

<Canvas of={Input.Mouse} />

<Source dark code={mouse} />

## Touch

The `touch()` behavior provides touch support for your game. It can distinguish between taps and swipes.

When you tap on an entity, it will trigger an `entityTouch` event with the entity's ID. If you tap on an empty area of the scene, a `sceneTouch` event is triggered with the position of the tap.

If you drag your finger across the screen, it will be detected as a swipe, and a `swipe` event will be triggered when you lift your finger.

<Canvas of={Input.Touch} />

<Source dark code={touch} />

## Keyboard and Gamepad

The recommended way to handle input from keyboards and gamepads is by using the unified `controls` behaviors.

The `controls()` and `createControls()` functions allow you to define input mappings that work for both keyboards and gamepads simultaneously, abstracting away the device-specific details. This makes your game's control logic cleaner and more flexible.

If you plug in a gamepad, there's a high chance that the engine will recognize it and you will be able to control your character with the D-pad or the left axis, using the same mapping.

<Canvas of={Input.Controls} />

<Source dark code={controls} />
