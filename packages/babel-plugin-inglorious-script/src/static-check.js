/**
 * Checks if a Babel AST node could potentially be a vector at runtime.
 * This is a permissive check - when in doubt, it returns true to allow
 * transformation and let runtime checks handle validation.
 */
export function couldBeVector(node, scope) {
  if (!node) {
    return false
  }

  // Direct calls to v() are definitely vectors
  if (
    node.type === "CallExpression" &&
    node.callee &&
    node.callee.type === "Identifier" &&
    node.callee.name === "v"
  ) {
    return true
  }

  // Helper functions (generated by plugin) return vectors
  if (
    node.type === "CallExpression" &&
    node.callee &&
    node.callee.type === "Identifier" &&
    node.callee.name.startsWith("__")
  ) {
    return true
  }

  // Any other function call could return a vector
  if (node.type === "CallExpression") {
    return true
  }

  // Member expressions could be vectors (obj.prop, obj['key'])
  if (node.type === "MemberExpression") {
    return true
  }

  // Check variables
  if (node.type === "Identifier") {
    const binding = scope.getBinding(node.name)
    if (!binding) {
      return false
    }

    const bindingNode = binding.path.node

    // Imports could be vectors
    if (bindingNode.type === "ImportSpecifier") {
      return true
    }

    // Check variable initializer
    if (bindingNode.init) {
      return couldBeVector(bindingNode.init, scope)
    }
  }

  // Binary expressions that could result in vectors
  if (node.type === "BinaryExpression") {
    const { operator, left, right } = node
    const leftCould = couldBeVector(left, scope)
    const rightCould = couldBeVector(right, scope)

    // vec + vec -> vec, vec - vec -> vec
    if (operator === "+" || operator === "-") {
      return leftCould || rightCould // Either operand could make this a vector operation
    }

    // vec * scalar -> vec, scalar * vec -> vec
    if (operator === "*") {
      return leftCould || rightCould // Could be vector scaling
    }

    // vec / scalar -> vec, vec % scalar -> vec, vec ** scalar -> vec
    if (["/", "%", "**"].includes(operator)) {
      return leftCould // Left operand could be a vector
    }
  }

  // Unary minus on vector: -vec -> vec
  if (node.type === "UnaryExpression" && node.operator === "-") {
    return couldBeVector(node.argument, scope)
  }

  // Literals are never vectors
  if (
    node.type === "NumericLiteral" ||
    node.type === "StringLiteral" ||
    node.type === "BooleanLiteral"
  ) {
    return false
  }

  // Default: could be anything, so return false for safety
  return false
}

/**
 * Checks if we're certain that a node is a vector (for static error checking).
 * This is more conservative - only returns true when we're 100% sure.
 */
export function isCertainlyVector(node, scope) {
  if (!node) {
    return false
  }

  // Direct calls to v() are definitely vectors
  if (
    node.type === "CallExpression" &&
    node.callee &&
    node.callee.type === "Identifier" &&
    node.callee.name === "v"
  ) {
    return true
  }

  // Helper functions (generated by plugin) return vectors
  if (
    node.type === "CallExpression" &&
    node.callee &&
    node.callee.type === "Identifier" &&
    node.callee.name.startsWith("__")
  ) {
    return true
  }

  // Check variables with known vector initializers
  if (node.type === "Identifier") {
    const binding = scope.getBinding(node.name)
    if (!binding) {
      return false
    }

    const bindingNode = binding.path.node
    if (bindingNode.init) {
      return isCertainlyVector(bindingNode.init, scope)
    }
  }

  // Binary expressions that definitely result in vectors
  if (node.type === "BinaryExpression") {
    const { operator, left, right } = node
    const leftCertain = isCertainlyVector(left, scope)
    const rightCertain = isCertainlyVector(right, scope)

    // vec + vec -> vec, vec - vec -> vec
    if (operator === "+" || operator === "-") {
      return leftCertain && rightCertain
    }

    // vec * scalar -> vec, scalar * vec -> vec (but only if we're certain about types)
    if (operator === "*") {
      return (
        (leftCertain && isCertainlyScalar(right, scope)) ||
        (isCertainlyScalar(left, scope) && rightCertain)
      )
    }

    // vec / scalar -> vec, vec % scalar -> vec, vec ** scalar -> vec
    if (["/", "%", "**"].includes(operator)) {
      return leftCertain && isCertainlyScalar(right, scope)
    }
  }

  // Unary minus on vector: -vec -> vec
  if (node.type === "UnaryExpression" && node.operator === "-") {
    return isCertainlyVector(node.argument, scope)
  }

  return false
}

/**
 * Checks if we're certain that a node is a scalar (for static error checking).
 */
export function isCertainlyScalar(node, scope) {
  if (!node) {
    return false
  }

  // Literals are definitely scalars
  if (
    node.type === "NumericLiteral" ||
    node.type === "StringLiteral" ||
    node.type === "BooleanLiteral"
  ) {
    return true
  }

  // Check variables with known scalar initializers
  if (node.type === "Identifier") {
    const binding = scope.getBinding(node.name)
    if (!binding) {
      return false
    }

    const bindingNode = binding.path.node
    if (bindingNode.init) {
      return isCertainlyScalar(bindingNode.init, scope)
    }
  }

  // Binary expressions between scalars result in scalars
  if (node.type === "BinaryExpression") {
    const { left, right } = node
    return isCertainlyScalar(left, scope) && isCertainlyScalar(right, scope)
  }

  // Unary operations on scalars result in scalars
  if (node.type === "UnaryExpression") {
    return isCertainlyScalar(node.argument, scope)
  }

  return false
}
