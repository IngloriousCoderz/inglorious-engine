import { Meta } from '@storybook/addon-docs/blocks'

import { toString as bToString } from '@inglorious/utils/data-structures/boolean'
import {
  clone,
  filter,
  find,
  isObject,
  map,
  produce,
  toString,
} from '@inglorious/utils/data-structures/object'

<Meta title="Utils/Data Structures/Object" />

# Object

Functions that deal with a single object.

## Clone

Creates a deep clone of an object. It uses `JSON.parse(JSON.stringify())` internally, so it has the same limitations (e.g., it will not clone functions, `undefined`, or `Symbol` properties).

<code>const obj = \{ a: 1, b: [2, 3], c: \{ d: 4 \} \}</code>&nbsp;

<code>clone(obj) == {toString(clone({ a: 1, b: [2, 3], c: { d: 4 } }))}</code>&nbsp;

## Filter

Behaves similar to `Array.prototype.filter`, returning an object that contains only properties that satisfy the given predicate.

<code>const predicate = (key) =&gt; ['key2', 'key3'].includes(key)</code>&nbsp;

<code>const obj =  \{ key1: 'value1', key2: 'value2', key3: 'value3' \}</code>&nbsp;

<code>filter(obj, predicate) == {toString(filter({ key1: 'value1', key2: 'value2', key3: 'value3' }, (key) => ['key2', 'key3'].includes(key)))}</code>&nbsp;

## Find

Behaves similar to `Array.prototype.find`, returning an object that contains only the first property that satisfies the given predicate.

<code>const predicate = (key) =&gt; ['key2', 'key3'].includes(key)</code>&nbsp;

<code>const obj = \{ key1: 'value1', key2: 'value2', key3: 'value3' \}</code>&nbsp;

<code>find(obj, predicate) == {toString(find({ key1: 'value1', key2: 'value2', key3: 'value3' }, (key) => ['key2', 'key3'].includes(key)))}</code>&nbsp;

## Map

Behaves similar to `Array.prototype.map`, returning an object that has values transformed according to the given callback.

<code>const callback = (key, value) =&gt; value.toUpperCase()</code>&nbsp;

<code>const obj = \{ key1: 'value1', key2: 'value2', key3: 'value3' \}</code>&nbsp;

<code>map(obj, callback) == {toString(map({ key1: 'value1', key2: 'value2', key3: 'value3' }, (key, value) => value.toUpperCase()))}</code>&nbsp;

## Is Object

Checks if a value is a plain JavaScript object (and not an array, `null`, or other object types like `Date`).

<code>isObject(\{ \}) == {bToString(isObject({}))}</code>&nbsp;

<code>isObject([]) == {bToString(isObject([]))}</code>&nbsp;

<code>isObject(null) == {bToString(isObject(null))}</code>&nbsp;

<code>isObject(new Date()) == {bToString(isObject(new Date()))}</code>&nbsp;

## Produce

A utility function inspired by Immer's `produce` API. It provides a convenient way to work with immutable data structures by allowing "mutations" on a temporary draft.

### Important Performance Note

Unlike Immer, which uses structural sharing via proxies for high performance, this implementation performs a **full deep clone** of the base state on every call using `JSON.parse(JSON.stringify())`.

This can be very inefficient for large or complex states. It is intended for simple use cases where the convenience of the API outweighs the performance cost. For performance-critical state updates, consider using a library like Immer directly.

### How It Works

The `recipe` function receives a draft copy of the state. It can either mutate the draft and return nothing (`undefined`), or it can return a completely new value, which will become the next state.

### Usage

The function can be called in two ways:

#### Standard Call

```javascript
import { produce } from '@inglorious/utils/data-structures/object';

const baseState = {
  user: { name: 'Alice', age: 30 },
  posts: [],
};

const nextState = produce(baseState, (draft) => {
  draft.user.age += 1;
  draft.posts.push({ id: 1, title: 'Hello World' });
});

console.log(nextState.user.age); // 31
console.log(baseState.user.age); // 30 (original state is untouched)
```

#### Curried Call

You can also create a reusable producer function by passing only the recipe.

```javascript
import { produce } from '@inglorious/utils/data-structures/object';

const incrementAge = produce((draft) => {
  draft.user.age += 1;
});

const state1 = { user: { name: 'Alice', age: 30 } };
const state2 = incrementAge(state1);

console.log(state2.user.age); // 31
console.log(state1.user.age); // 30
```
