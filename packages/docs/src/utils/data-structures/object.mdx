import { Meta } from '@storybook/addon-docs/blocks'

import { filter, find, map, produce, toString } from '@inglorious/utils/data-structures/object'

<Meta title="Utils/Data Structures/Object" />

# Object

Functions that deal with a single object.

## Filter

Behaves similar to `Array.prototype.filter`, returning an object that contains only properties that satisfy the given predicate.

<code>const predicate = (key) =&gt; ['key2', 'key3'].includes(key)</code>&nbsp;

<code>const obj =  \{ key1: 'value1', key2: 'value2', key3: 'value3' \}</code>&nbsp;

<code>filter(obj, predicate) == {toString(filter({ key1: 'value1', key2: 'value2', key3: 'value3' }, (key) => ['key2', 'key3'].includes(key)))}</code>&nbsp;

## Find

Behaves similar to `Array.prototype.find`, returning an object that contains only the first property that satisfies the given predicate.

<code>const predicate = (key) =&gt; ['key2', 'key3'].includes(key)</code>&nbsp;

<code>const obj = \{ key1: 'value1', key2: 'value2', key3: 'value3' \}</code>&nbsp;

<code>find(obj, predicate) == {toString(find({ key1: 'value1', key2: 'value2', key3: 'value3' }, (key) => ['key2', 'key3'].includes(key)))}</code>&nbsp;

## Map

Behaves similar to `Array.prototype.map`, returning an object that has values transformed according to the given callback.

<code>const callback = (key, value) =&gt; value.toUpperCase()</code>&nbsp;

<code>const obj = \{ key1: 'value1', key2: 'value2', key3: 'value3' \}</code>&nbsp;

<code>map(obj, callback) == {toString(map({ key1: 'value1', key2: 'value2', key3: 'value3' }, (key, value) => value.toUpperCase()))}</code>&nbsp;

## Produce

A utility function inspired by Immer's `produce` API. It provides a convenient way to work with immutable data structures by allowing "mutations" on a temporary draft.

### Important Performance Note

Unlike Immer, which uses structural sharing via proxies for high performance, this implementation performs a **full deep clone** of the base state on every call using `JSON.parse(JSON.stringify())`.

This can be very inefficient for large or complex states. It is intended for simple use cases where the convenience of the API outweighs the performance cost. For performance-critical state updates, consider using a library like Immer directly.

### How It Works

The `recipe` function receives a draft copy of the state. It can either mutate the draft and return nothing (`undefined`), or it can return a completely new value, which will become the next state.

### Usage

The function can be called in two ways:

#### Standard Call

```javascript
import { produce } from '@inglorious/utils/data-structures/object';

const baseState = {
  user: { name: 'Alice', age: 30 },
  posts: [],
};

const nextState = produce(baseState, (draft) => {
  draft.user.age += 1;
  draft.posts.push({ id: 1, title: 'Hello World' });
});

console.log(nextState.user.age); // 31
console.log(baseState.user.age); // 30 (original state is untouched)
```

#### Curried Call

You can also create a reusable producer function by passing only the recipe.

```javascript
import { produce } from '@inglorious/utils/data-structures/object';

const incrementAge = produce((draft) => {
  draft.user.age += 1;
});

const state1 = { user: { name: 'Alice', age: 30 } };
const state2 = incrementAge(state1);

console.log(state2.user.age); // 31
console.log(state1.user.age); // 30
```
