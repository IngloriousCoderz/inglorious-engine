import { Meta } from '@storybook/addon-docs/blocks'

import {
  abs,
  angle,
  clamp,
  conjugate,
  divide,
  from2D,
  fromAngle,
  isVector,
  magnitude,
  mod,
  multiply,
  normalize,
  power,
  rotate,
  setAngle,
  setMagnitude,
  shift,
  to2D,
  toCartesian,
  toCylindrical,
  toPolar,
  toSpherical,
  toString,
  unit,
  zero,
} from '@inglorious/utils/math/vector'
import { pi, cos, sin } from '@inglorious/utils/math/trigonometry'

<Meta title="Utils/Math/Vector" />

# Vector

Functions that deal with a single vector.

## Abs

Returns the absolute value of each component in the vector.

<code>abs([-2, 0, 3]) == {toString(abs([-2, 0, 3]))}</code>&nbsp;

## Angle

Returns the angle of a vector, calculated as the `atan2` between the last and first coordinate.

<code>angle([1, 1]) == {angle([1, 1]).toFixed(3)}</code> (&asymp;&pi;/4)

<code>angle([1, 0, 1]) == {angle([1, 0, 1]).toFixed(3)}</code> (&asymp;&pi;/4)

## Clamp

Limits the magnitude of a vector to a lower and upper bound.

<code>clamp([6, 8], 0, 5) == {toString(clamp([6, 8], 0, 5))}</code>&nbsp;

<code>clamp([3, 4], 0, 5) == {toString(clamp([3, 4], 0, 5))}</code>&nbsp;

Bounds can be specified as other vectors too.

<code>clamp([6, 8], [0, 0], [3, 4]) == {toString(clamp([6, 8], [0, 0], [3, 4]))}</code>&nbsp;

## Conjugate

Flips the sign of all coordinates except the first one.

<code>conjugate([1, 2, 3]) == {toString(conjugate([1, 2, 3]))}</code>&nbsp;

## Divide

Divides any vector by a scalar.

<code>divide([4, 8, 12], 4) == {toString(divide([4, 8, 12], 4))}</code>&nbsp;

## From 2D

Builds a 3D vector from a 2D one.

<code>from2D([3, 4]) == {toString(from2D([3, 4]))}</code>&nbsp;

## From Angle

Creates a 3D unit vector from a given angle.

<code>fromAngle(pi() / 4) == {toString(fromAngle(pi() / 4))}</code>&nbsp;

## Is Vector

Checks if a value is a vector (an array of numbers). For performance, vectors created with `v()` are tagged and can be identified more quickly.

<code>isVector([1, 2, 3]) == {isVector([1, 2, 3]).toString()}</code>&nbsp;

<code>isVector([1, 'a', 3]) == {isVector([1, 'a', 3]).toString()}</code>&nbsp;

## Length

Alias of `magnitude`.

## Magnitude

Computes the magnitude of any vector (alias `length`).

<code>magnitude([3, 4]) == {magnitude([3, 4])}</code>&nbsp;

## Mod

Applies the `mod` operator on any vector (alias `remainder`).

<code>mod([10, 12, -18], 12) == {toString(mod([10, 12, -18], 12))}</code>&nbsp;

## Multiply

Multiplies a vector with a scalar (alias `times`).

<code>multiply([1, 2, 3], 4) == {toString(multiply([1, 2, 3], 4))}</code>&nbsp;

## Normalize

Gives the vector unit length while maintaining its angle.

<code>normalize([3, 4]) == {toString(normalize([3, 4]), 1)}</code>&nbsp;

<code>normalize([-3, -4]) == {toString(normalize([-3, -4]), 1)}</code>&nbsp;

## Power

Raises each component of the vector to the given exponent.

<code>power([1, 2, 3], 2) == {toString(power([1, 2, 3], 2), 0)}</code>&nbsp;

## Remainder

Alias of `mod`.

## Rotate

Adds the given angle to a 2D or 3D vector using quaternions.

<code>rotate([1, 0], 0) == {toString(rotate([1, 0], 0))}</code>&nbsp;

<code>rotate([1, 0], pi() / 4) == {toString(rotate([1, 0], pi() / 4), 3)}</code> (&asymp;[cos(&pi;/4), sin(&pi;/4)])

<code>rotate([1, 0, 0], 0) == {toString(rotate([1, 0, 0], 0))}</code>&nbsp;

<code>rotate([1, 0, 0], pi() / 4) == {toString(rotate([1, 0, 0], pi() / 4), 3)}</code> (&asymp;[cos(&pi;/4), 0, sin(&pi;/4)])

<code>rotate([-1, 0, 0], pi() / 4) == {toString(rotate([-1, 0, 0], pi() / 4), 3)}</code> (&asymp;[cos(-3/4*&pi;), 0, sin(-3/4*&pi;)])

## Set Angle

Changes the angle of a vector.

<code>setAngle([cos(pi() / 4), 0, sin(pi() / 4)], pi() / 2) == {toString(setAngle([cos(pi() / 4), 0, sin(pi() / 4)], pi() / 2))}</code>&nbsp;

## Set Magnitude

Changes the magnitude of any vector, keeping its angle.

<code>setMagnitude([3, 4], 10) == {toString(setMagnitude([3, 4], 10))}</code>&nbsp;

<code>setMagnitude([-3, -4], 10) == {toString(setMagnitude([-3, -4], 10))}</code>&nbsp;

## Shift

Moves coordinates around by a certain index.

<code>shift([1, 2, 3, 4, 5], 2) == {toString(shift([1, 2, 3, 4, 5], 2))}</code>&nbsp;

## Times

Alias of `multiply`.

## To 2D

Builds a 2D vector from a 3D one.

<code>to2D([3, 0, 4]) == {toString(to2D([3, 0, 4]))}</code>&nbsp;

## To Cartesian

Converts a 2D polar vector into cartesian coordinates.

<code>toCartesian([2 ** 0.5, pi() / 4]) == {toString(toCartesian([2 ** 0.5, pi() / 4]))}</code>&nbsp;

## To Cylindrical

Converts a 3D cartesian vector to cylindrical coordinates.

<code>toCylindrical([1, 1, 1]) == {toString(toCylindrical([1, 1, 1]), 3)}</code>&nbsp;

## To Polar

Converts a 2D cartesian vector to polar coordinates.

<code>toPolar([1, 1]) == {toString(toPolar([1, 1]), 3)}</code> (&asymp;[&#8730;2, &pi;/4])

## To Spherical

Converts a 3D cartesian vector to spherical coordinates.

<code>toSpherical([1, 1, 1]) == {toString(toSpherical([1, 1, 1]), 3)}</code>&nbsp; (&asymp;[&#8730;3, arccos(1/&#8730;3), &pi;/4])

## To String

Returns a string representation of any vector, up to optional decimal points.

<code>toString([1, 0]) == "{toString([1, 0])}"</code>&nbsp;

<code>toString([cos(pi() / 4), 0], 3) == "{toString([cos(pi() / 4), 0], 3)}"</code>&nbsp;

## Unit

Returns a unit 3D vector at a given optional angle.

<code>unit() == {toString(unit())}</code>&nbsp;

<code>unit(pi() / 2) == {toString(unit(pi() / 2))}</code>&nbsp;

## Zero

Creates a zero vector of 3 dimensions.

<code>zero() == {toString(zero())}</code>&nbsp;
