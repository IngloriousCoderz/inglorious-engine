import { Canvas, Meta, Source, Story } from '@storybook/addon-docs/blocks'
import * as CoreConcepts from './core-concepts.stories'

import bounds from './bounds?raw'
import codeReuse from './code-reuse?raw'
import eventHandlers from './event-handlers?raw'
import framerate from './framerate?raw'

<Meta of={CoreConcepts} />

# Core Concepts

The Inglorious Engine is built around a few core concepts that work together to create your game. Understanding these will help you build games more effectively.

## The Engine and Game Loop

The heart of the engine is the game loop, which continuously updates the game state and renders it to the screen. You can configure the loop, for example, to run at a fixed framerate.

## The Configuration Object

You configure your game by passing a configuration object to the `Engine`. This object defines everything about your game: types, entities, and systems.

## Entities

Entities are the "things" in your game world. An entity is a simple object with an `id` and a collection of properties. For example, a player character, a bullet, or an enemy are all entities.

## Types and Behaviors

To avoid duplicating logic and properties for similar entities, you can define **Types**. A type is a template for entities. It's an array of **Behaviors**, which are reusable pieces of logic and properties. When an entity is created with a `type`, it inherits all the behaviors from that type.

## Systems

While Behaviors are great for entity-specific logic, **Systems** are used for global logic that can affect multiple entities. They are functions that run on every frame and have access to the entire game state. This makes them perfect for things like physics, animation, or AI that needs to coordinate between entities.

You can learn more about the power of **[Systems and how they compare to Behaviors](/docs/engine-systems--docs)**.

# Deep Dive

As you already saw in the **[Quickstart](/docs/quick-start--docs)**, the Inglorious Engine is a headless game engine that takes a configuration file in plain JavaScript and creates a scene. The UI can be implemented in any technology: canvas, HTML, ...here we are using React components.

Here are a few examples of what you can do.

## Bounds

The `game` entity is already defined for you. But if you want to customize its size you can just redefine it: every property will be merged with the defaults. See how redefining the game's size will change its bounds.

<Canvas of={CoreConcepts.Bounds} />

<Source dark code={bounds} />

## Event Handlers

To animate stuff we write event handlers for events that are triggered by our entities or by the game itself. The `update` event, for example, is a special core event that is triggered at every cycle of the game loop.

An event handler accepts the following arguments:

- The `entity` itself that is handling the event, so we can change its properties to our needs.
- The event's `payload`, which contains data relevant to the event. For the special `update` event, this is the delta time (`dt`).
- The engine's `api` object, which provides safe access to engine functionalities like `getEntity(id)`, `getEntities()`, and `notify(type, payload)`.

You might notice the code directly changes properties on the `entity`. While this looks like a direct mutation, the engine uses [Immer](https://immerjs.github.io/immer/) under the hood. This allows you to write simple, mutable-style code while Immer handles the complexity of producing a new, immutable state object for you. It's the best of both worlds: simple code and the safety of immutability.

### Naming Conventions

The engine uses a simple and powerful naming convention for events to ensure clarity and prevent conflicts:

- **Core Engine Events are single words**: These are reserved, special-purpose commands like `update`, `add`, `remove`, and `morph`.
- **Custom Game Events are multi-word (`camelCase`)**: For all your game-specific logic, you should use descriptive, multi-word names like `playerJump`, `enemyTakeDamage`, or `itemCollect`.

This convention acts as a form of namespacing, similar to how custom HTML elements must contain a hyphen (e.g., `<my-component>`) to distinguish them from standard elements (e.g., `<div>`). It makes it immediately clear which events are part of the engine's lifecycle and which are specific to your game's logic.

The character shown here uses the `update` event to update its velocity and position at every frame, going back and forth like it's patroling the scene!

The `fps` type shows FPS debug info on the top left of the scene; its value is updated based on the `dt` time at every `update` event.

<Canvas of={CoreConcepts.EventHandlers} />

<Source dark code={eventHandlers} />

## Code Reuse

Coding is beautiful, but reusing code without reinventing the wheel is even better! This is where the engine's functional approach really shines through its **[Composition over Inheritance](/docs/engine-core-concepts-composition--docs)** philosophy.

Instead of relying on complex class inheritance hierarchies, we use **behavior composition**. A `type` is defined as an array of *behaviors*â€”plain JavaScript objects that contain event handlers. The engine merges these objects to create the final, composite behavior for the type.

This approach is more flexible and powerful than inheritance. You can mix and match behaviors by simply adding new objects to the type's array, avoiding problems like the "diamond problem" and creating deeply nested, brittle class structures.

The event handler for this character is also using a predefined `bounce()` function. There are many predefined functions out there at your disposal, just look through the documentation to find the ones that suit you best.

<Canvas of={CoreConcepts.CodeReuse} />

<Source dark code={codeReuse} />

## Dynamic Entities

A key advantage of building games in JavaScript is the language's inherent flexibility. Unlike in many statically-typed languages, JavaScript objects are dynamic. You can add, modify, or remove properties from any `entity` at runtime without needing to pre-define them in its `type`.

This is incredibly useful in game development. For example, if a character picks up a temporary power-up, you can simply attach a new property to the character's entity to manage its state.

### Example

Imagine an event handler for a collision between a player and a power-up item.

```javascript
// In a 'collision' event handler for the player entity...
entity.powerUp = { type: 'speed', duration: 10 }; // 10 seconds

// Later, in the 'game:update' event handler for the player...
if (entity.powerUp?.type === 'speed') {
    // This function would increase the player's speed
    // (Remember, Immer handles immutability for you!)
    entity.velocity[0] *= 1.5;
    entity.velocity[1] *= 1.5;

    entity.powerUp.duration -= dt;

    if (entity.powerUp.duration <= 0) {
        // Power-up has expired, remove the property.
        delete entity.powerUp;
    }
}
```

This approach allows for rapid prototyping and the creation of emergent game mechanics without being constrained by rigid class structures, which aligns perfectly with the engine's data-oriented and functional philosophy.

## Dynamic Types

While adding properties to individual entities at runtime is powerful for temporary state changes, sometimes you need to fundamentally alter the behavior of all entities of a certain type. The engine supports this through the `morph` event.

This allows you to redefine a type's decorators and event handlers on the fly. This is particularly useful for implementing mechanics like character evolution or complex power-up systems where the core behaviors of a character change.

### Example: Mario's Power-Ups

Let's revisit the classic Super Mario example. When Mario picks up a power-up, his abilities change. Instead of managing boolean flags on the entity (`canBreakBricks`, `canShootFire`), we can dynamically change the `mario` type itself.

Here's how you might dispatch a `morph` event upon collision with a Fire Flower:

```javascript
// In a collision event handler for Mario...
if (collidesWith(mario, fireFlower)) {
    api.notify("morph", {
        id: 'mario', // The ID of the type to change
        type: [ // The new array of behaviors and handlers
            baseMario(),
            superMario(),
            fireMario(),
            // ... other base behaviors like controls, physics etc.
        ],
    });
    // remove the power-up from the scene
    api.notify("remove", fireFlower.id);
}
```

When the engine processes this event, it will replace the existing definition for the `mario` type with the new one. All existing and future entities of `type: 'mario'` will now use the new set of behaviors, including the abilities from `fireMario()`.

This pattern keeps entity objects clean and centralizes behavior logic within type definitions, making your game architecture more robust and easier to reason about. You can see a complete implementation of this pattern in the Mario Power-Ups recipe.

## Performance Considerations

### The Myth of Slow Immutability

A common concern with immutable architectures is the perceived overhead of creating a new state object for every single change. In practice, this is a misconception.

Inglorious Engine uses modern techniques (specifically, the Immer library) to implement **structural sharing**. When you modify the state, only the parts of the data tree that are affected are actually copied. All other parts of the tree are shared by reference with the previous state.

This means that state updates are incredibly cheap and fast, regardless of the total size of your game state.

### The Benefit: Optimized Rendering

This immutable approach provides a major performance benefit, especially for rendering. To determine if a UI component needs to be rerendern, you can perform a simple and highly efficient reference equality check (`prevState.player === nextState.player`).

- If the reference is the same, the object hasn't changed, and no re-render is needed.
- If the reference is different, the object has changed, and it needs to be re-rendered.

This is orders of magnitude faster than the deep, recursive comparisons required to detect changes in a mutable state tree, and it's the secret behind the performance of modern web frameworks like React.

### Pragmatic Optimizations: Entity Pooling

While immutability is the default and preferred approach, the engine's philosophy is pragmatic. For extremely high-frequency, short-lived objects (e.g., hundreds of bullets per second), the overhead of even fast immutable updates can add up.

In these specific, performance-critical scenarios, the engine provides a built-in entity pooling system. This advanced pattern acts as an "escape hatch" for when raw performance is the absolute top priority, allowing you to manage a pool of mutable entities outside the main immutable state tree without compromising the stability and predictability of the rest of your game state. You can see a complete implementation of this pattern in the **[Entity Pooling docs](/docs/engine-pooling--docs)**.

## Fixed Framerate

What if you want to provide a more retro feel to your game? You can use a fixed framerate and make your animations more jerky by changing the default loop.

<Canvas of={CoreConcepts.Framerate} />

<Source dark code={framerate} />

## What's Next?

You've now seen the core features of the engine. Here's where you can go from here:

- **Add player controls**: See **[Input Handling](/docs/engine-input--docs)** for keyboard and mouse.
- **Detect collisions**: Learn about **[Collision Detection](/docs/engine-collision-detection--docs)**.
- **Build autonomous characters**: Explore **[AI Kinematic Movement](/docs/engine-ai-movement-kinematic--docs)** and **[AI Dynamic Movement](/docs/engine-ai-movement-dynamic--docs)**.
- **See complete examples**: Look at our **[Recipes](/docs/engine-recipes--docs)** for common game patterns.
- **Explore helper functions**: Check out the **[Utilities](/docs/utils-docs--docs)** available for common tasks.