import { Meta } from '@storybook/blocks'

import { filter, find, map, toString } from '@inglorious/utils/data-structures/object'

<Meta title="Utils/Data Structures/Object" />

# Object

Functions that deal with a single object.

## Filter

Behaves similar to `Array.prototype.filter`, returning an object that contains only properties that satisfy the given predicate.

<code>const predicate = (key) =&gt; ['key2', 'key3'].includes(key)</code>&nbsp;

<code>const obj =  \{ key1: 'value1', key2: 'value2', key3: 'value3' \}</code>&nbsp;

<code>filter(obj, predicate) == {toString(filter({ key1: 'value1', key2: 'value2', key3: 'value3' }, (key) => ['key2', 'key3'].includes(key)))}</code>&nbsp;

## Find

Behaves similar to `Array.prototype.find`, returning an object that contains only the first property that satisfies the given predicate.

<code>const predicate = (key) =&gt; ['key2', 'key3'].includes(key)</code>&nbsp;

<code>const obj = \{ key1: 'value1', key2: 'value2', key3: 'value3' \}</code>&nbsp;

<code>find(obj, predicate) == {toString(find({ key1: 'value1', key2: 'value2', key3: 'value3' }, (key) => ['key2', 'key3'].includes(key)))}</code>&nbsp;

## Map

Behaves similar to `Array.prototype.map`, returning an object that has values transformed according to the given callback.

<code>const callback = (key, value) =&gt; value.toUpperCase()</code>&nbsp;

<code>const obj = \{ key1: 'value1', key2: 'value2', key3: 'value3' \}</code>&nbsp;

<code>map(obj, callback) == {toString(map({ key1: 'value1', key2: 'value2', key3: 'value3' }, (key, value) => value.toUpperCase()))}</code>&nbsp;

## To String

Returns a string representation of a given object.

<code>const obj = \{ key1: 'value1', key2: 'value2', key3: 'value3' \}</code>&nbsp;

<code>toString(obj) == "{toString({ key1: 'value1', key2: 'value2', key3: 'value3' })}"</code>&nbsp;
