import { Canvas, Meta, Source } from '@storybook/blocks'
import * as Engine from './engine.stories'

import bounds from './bounds?raw'
import codeReuse from './code-reuse?raw'
import eventHandlers from './event-handlers?raw'
import framerate from './framerate?raw'

<Meta of={Engine} />

# Core Concepts

This page showcases some of the core concepts and features of the Inglorious Engine. If you are just getting started, we recommend you check out the [Quick Start Guide](/docs/quick-start--docs) first.

Inglorious Engine is a headless game engine that takes a configuration file in plain JavaScript and creates a scene. The UI can be implemented in any technology: canvas, HTML, ...here we are using React components.

Here are a few examples of what you can do.

## Bounds

We can customize the game's bounds by passing an array of four numbers: these will hold the upper and lower bounds in pixels.

The game is an instance in the game, that we can customize as we please.

<Source dark code={bounds} />

<Canvas of={Engine.Bounds} />

## Event Handlers

To animate stuff we write event handlers for events that are triggered by our instances or by the game itself. The `game:update` event, for example, is triggered at every cycle of the game loop.

An event handler accepts the following arguments:

- The `instance` itself that is handling the event, so we can change its properties to our needs;
- The triggered `event`, which contains a `payload` that holds whatever we need to accomplish our task;
- An `options` object that contains the following:
  - The elapsed time `dt`, which can help slow down certain movement algorithms based on the current FPS;
  - The game's current `config` object (here you can find the scene's `bounds`, for example);
  - All `instances` present in the scene; note that they are read-only, so look but don't touch!

The character shown here updates its velocity and position at every frame, going back and forth like it's patroling the scene!

The `fps` type shows FPS debug info on the top left of the scene; its value is updated based on the `dt` time at every `game:update` event.

<Source dark code={eventHandlers} />

<Canvas of={Engine.EventHandlers} />

## Code Reuse

Coding is beautiful, but reusing code without reinventing the wheel is even better!

All the code necessary to draw the character is now encapsulated in a `enableCharacter()` function. To be precise, this is a decorator. Note how the `character` type can now accept an array of decorators: you can combine as many decorators as you wish to give the character new features!

The event handler for this character is using a predefined `bounce()` function which makes it look like one of those old DVD logo screensavers. There are many predefined functions out there at your disposal, just look into the docz to find the ones that suit you best.

<Source dark code={codeReuse} />

<Canvas of={Engine.CodeReuse} />

## Fixed Framerate

What if you want to provide a more retro feel to your game? You can use a fixed framerate and make your animations more jerky by changing the default loop.

<Source dark code={framerate} />

<Canvas of={Engine.Framerate} />

## What's Next?

You've now seen the core features of the engine. Here's where you can go from here:

- **Add player controls**: See [Input Handling](/docs/engine-input--docs) for keyboard and mouse.
- **Detect collisions**: Learn about [Collision Detection](/docs/engine-collision-detection--docs).
- **Build autonomous characters**: Explore [AI Kinematic Movement](/docs/ai-movement-kinematic--docs) and [AI Dynamic Movement](/docs/ai-movement-dynamic--docs).
- **See complete examples**: Look at our [Recipes](/docs/engine-recipes--docs) for common game patterns.