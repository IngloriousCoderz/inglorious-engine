import { Canvas, Meta, Source } from '@storybook/addon-docs/blocks'
import * as Recipes from './recipes.stories'

import addAndRemove from './add-and-remove?raw'
import addEntity from './add-entity?raw'
import decisionTree from './decision-tree?raw'
import marioPowerups from './mario-powerups?raw'
import randomEntities from './random-entities?raw'
import removeEntity from './remove-entity?raw'
import states from './states?raw'

<Meta of={Recipes} />

# Recipes

Some common patterns that can be used in your game. Check the source code of each recipe and take inspiration!

## Spawning Random Entities

The game configuration is pure JavaScript, so there's not much difference between defining the entities one by one or writing some code that generates them automatically!

Here we are using a couple of utility functions from the [rng](/docs/utils-math-rng--docs) and [trigonometry](/docs/utils-math-trigonometry--docs) packages.

<Source dark code={randomEntities} />

<Canvas of={Recipes.RandomEntities} />

## Adding An Entity

Programmatically adding a new entity to the scene is as easy as sending an event to the game engine asking nicely.

Try clicking anywhere on the scene to create a new entity with random orientation.

Here, apart from some math functions, we are also using a predefined mouse [input](/docs/engine-input--docs) package that allows us to position a cursor and handle its events.

<Source dark code={addEntity} />

<Canvas of={Recipes.AddEntity} />

## Removing An Entity

Removing an entity is pretty much the same: we notify the engine of our intention and we enjoy the result.

Try clicking on any entity do remove it from the scene.

<Source dark code={removeEntity} />

<Canvas of={Recipes.RemoveEntity} />

## Add And Remove

Clicking on a character will prevent the event from bubbling on the scene, so it's safe to add and remove characters by using the same strategy: click as if there's no tomorrow!

The most complex part of this code is generating new incremental ids, which is not even mandatory. You know best what's good for your game!

<Source dark code={addAndRemove} />

<Canvas of={Recipes.AddAndRemove} />

## States

Adding a states to our character is very easy, in fact every game so far was secretely using states already!

We just need to wrap our event handlers into a `states` object, set an initial `state` on our entity, and transition from one state to another inside our event handlers.

Try moving the cursor near the character to make it hunt you, and then moving it away to see the character wander around aimlessly.

This code may seem a lot, but it's just a merge of the *Arrive* and *Wander* [Kinematic AI Movement](/docs/engine-ai-movement-kinematic--docs) examples so feel free to take a look at them before approaching this one.

<Source dark code={states} />

<Canvas of={Recipes.States} />

## Decision Trees

Decision trees are another sweet feature built-in inside of Inglorious Engine. The following example doesn't really need one, but why not?

This game also showcases sprites!

<Source dark code={decisionTree} />

<Canvas of={Recipes.DecisionTree} />

## Dynamic Behaviors

This recipe shows how to implement a power-up system like in Super Mario. It's a practical example of the engine's **[Composition over Inheritance](/docs/engine-core-concepts-composition--docs)** philosophy, where we dynamically change the character's type definition at runtime through the `morph` event.

<Source dark code={marioPowerups} />

<Canvas of={Recipes.MarioPowerups} />
