import { Canvas, Meta, Source } from '@storybook/addon-docs/blocks'
import * as Recipes from './recipes.stories'

import randomEntities from './random-entities?raw'
import addEntity from './add-entity?raw'
import removeEntity from './remove-entity?raw'
import addAndRemove from './add-and-remove?raw'
import dynamicBehaviors from './dynamic-behaviors?raw'

<Meta of={Recipes} />

# Recipes

Some common patterns that can be used in your game. Check the source code of each recipe and take inspiration!

## Spawning Random Entities

The game configuration is pure JavaScript, so there's not much difference between defining the entities one by one or writing some code that generates them automatically!

Here we are using a couple of utility functions from the [rng](/docs/utils-math-rng--docs) and [trigonometry](/docs/utils-math-trigonometry--docs) packages.

<Canvas of={Recipes.RandomEntities} />

<Source dark code={randomEntities} />

## Adding An Entity

Programmatically adding a new entity to the scene is as easy as sending an event to the game engine asking nicely.

Try clicking anywhere on the scene to create a new entity with random orientation.

Here, apart from some math functions, we are also using a predefined mouse [input](/docs/engine-input--docs) package that allows us to position a cursor and handle its events.

<Canvas of={Recipes.AddEntity} />

<Source dark code={addEntity} />

## Removing An Entity

Removing an entity is pretty much the same: we notify the engine of our intention and we enjoy the result.

Try clicking on any entity do remove it from the scene.

<Canvas of={Recipes.RemoveEntity} />

<Source dark code={removeEntity} />

## Add And Remove

Clicking on a character will prevent the event from bubbling on the scene, so it's safe to add and remove characters by using the same strategy: click as if there's no tomorrow!

The most complex part of this code is generating new incremental ids, which is not even mandatory. You know best what's good for your game!

<Canvas of={Recipes.AddAndRemove} />

<Source dark code={addAndRemove} />

## Dynamic Behaviors

This recipe demonstrates how to implement a power-up system, similar to Super Mario picking up a mushroom. It's a practical example of the engine's **Composition over Inheritance** philosophy.

In this engine, an entity's 'type' is not a rigid class, but simply a collection of behaviors. By sending a `morph` event, we can dynamically add or remove behaviors at runtime, effectively changing the character's abilities and appearance on the fly. This approach avoids complex inheritance hierarchies and makes creating dynamic game mechanics much more flexible.

<Canvas of={Recipes.DynamicBehaviors} />

<Source dark code={dynamicBehaviors} />
