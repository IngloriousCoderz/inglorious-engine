import { Meta } from '@storybook/addon-docs/blocks'

import { filter, find, map, produce, toString } from '@inglorious/utils/data-structures/object'

<Meta title="Utils/Data Structures/Object" />

# Object

Functions that deal with a single object.

## Filter

Behaves similar to `Array.prototype.filter`, returning an object that contains only properties that satisfy the given predicate.

<code>const predicate = (key) =&gt; ['key2', 'key3'].includes(key)</code>&nbsp;

<code>const obj =  \{ key1: 'value1', key2: 'value2', key3: 'value3' \}</code>&nbsp;

<code>filter(obj, predicate) == {toString(filter({ key1: 'value1', key2: 'value2', key3: 'value3' }, (key) => ['key2', 'key3'].includes(key)))}</code>&nbsp;

## Find

Behaves similar to `Array.prototype.find`, returning an object that contains only the first property that satisfies the given predicate.

<code>const predicate = (key) =&gt; ['key2', 'key3'].includes(key)</code>&nbsp;

<code>const obj = \{ key1: 'value1', key2: 'value2', key3: 'value3' \}</code>&nbsp;

<code>find(obj, predicate) == {toString(find({ key1: 'value1', key2: 'value2', key3: 'value3' }, (key) => ['key2', 'key3'].includes(key)))}</code>&nbsp;

## Map

Behaves similar to `Array.prototype.map`, returning an object that has values transformed according to the given callback.

<code>const callback = (key, value) =&gt; value.toUpperCase()</code>&nbsp;

<code>const obj = \{ key1: 'value1', key2: 'value2', key3: 'value3' \}</code>&nbsp;

<code>map(obj, callback) == {toString(map({ key1: 'value1', key2: 'value2', key3: 'value3' }, (key, value) => value.toUpperCase()))}</code>&nbsp;

## Produce

A simplified, curried version of Immer's `produce`. It allows you to work with immutable data structures as if they were mutable, without having to worry about accidentally changing the original state.

### Basic Usage: Mutating the Draft

The most common way to use `produce` is to pass it a base state and a "recipe" function. This recipe function receives a `draft` of the state, which you can freely mutate. `produce` will handle the logic to create a new, updated state immutably.

<code>const baseState = \{ a: 1, b: \{ c: [2, 3] \} \}</code>&nbsp;
<code>const recipe = (draft) => \{ draft.a = 10; draft.b.c.push(4); \}</code>&nbsp;
<code>produce(baseState, recipe) == {toString(produce({ a: 1, b: { c: [2, 3] } }, (draft) => { draft.a = 10; draft.b.c.push(4); }))}</code>&nbsp;

### Returning a New State

Alternatively, the recipe can return a completely new state. If the recipe returns any value other than `undefined`, that value will be used as the next state. This is useful for simple updates.

<code>const baseState = \{ value: 1 \}</code>&nbsp;
<code>const recipe = (draft) => (\{ ...draft, wasChanged: true \})</code>&nbsp;
<code>produce(baseState, recipe) == {toString(produce({ value: 1 }, (draft) => ({ ...draft, wasChanged: true })))}</code>&nbsp;

### Passing Extra Arguments

You can pass additional arguments to `produce`, which will be forwarded to your recipe function after the `draft` state.

<code>const baseState = \{ value: 10 \}</code>&nbsp;
<code>const recipe = (draft, amount) => \{ draft.value += amount; \}</code>&nbsp;
<code>produce(baseState, recipe, 5) == {toString(produce({ value: 10 }, (draft, amount) => { draft.value += amount; }, 5))}</code>&nbsp;

### Currying

`produce` also supports currying. You can call it with just a recipe function to create a reusable "producer" function. This producer can then be called with a state and any extra arguments. This is very useful for event handlers in state management.

<code>const incrementBy = (draft, amount) => \{ draft.value += amount; \}</code>&nbsp;
<code>const incrementer = produce(incrementBy)</code>&nbsp;
<code>const baseState = \{ value: 10 \}</code>&nbsp;
<code>incrementer(baseState, 5) == {toString(produce((draft, amount) => { draft.value += amount; })({ value: 10 }, 5))}</code>&nbsp;

## To String

Returns a string representation of a given object.

<code>const obj = \{ key1: 'value1', key2: 'value2', key3: 'value3' \}</code>&nbsp;

<code>toString(obj) == "{toString({ key1: 'value1', key2: 'value2', key3: 'value3' })}"</code>&nbsp;
