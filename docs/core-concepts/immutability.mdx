import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="Engine/Core Concepts/Immutability" />

# Immutability

The engine's state is **immutable**. This means that you cannot change the state directly. Instead, you must `notify` the engine of events that describe the changes you want to make.

## Why Immutability?

Developing with immutable data encourages you to think differently about how data flows through your application. It leads to:
-   **Predictable State Changes:** State can only change in response to events, making it easier to reason about and debug.
-   **Performance Optimizations:** It's easy to detect if the state has changed by simply checking for reference equality (`===`). This is used by UI libraries like React to avoid unnecessary re-renders.
-   **Time-Travel Debugging:** Since each state is a separate object, you can store a history of states and "travel" back and forth, which is a powerful debugging tool provided by the Redux DevTools.

## Working with Immutable State

The engine uses the **[Immer](https://immerjs.github.io/immer/)** library to manage its state. This provides a powerful and convenient way to work with immutable data.

### Mutating the Current Entity

Inside an event handler (like `update`, `start`, or `mouseClick`), the **first parameter** is a special, mutable "draft" of the entity handling the event. You can change its properties directly. Immer will safely record these changes and produce a new, immutable state without you having to worry about it.

    ```javascript
    // Inside a behavior
    {
      update(entity, dt, api) {
        // `entity` is a mutable draft. You can change it directly.
        entity.position[0] += entity.velocity[0] * dt;
        entity.position[2] += entity.velocity[2] * dt;
      }
    }
    ```

This makes writing update logic feel natural, while still getting all the benefits of immutability.

### Interacting with Other Entities

When you need to interact with a *different* entity, you retrieve it using the `api`, for example `api.getEntity('player')`.

**Entities retrieved from the `api` are read-only.**

Because the state is frozen by Immer, any attempt to directly mutate an entity retrieved from the `api` will fail and throw a `TypeError`.

```javascript
// This will throw a TypeError because the state is frozen.
const player = api.getEntity('player');
player.health -= 10; // ‚ùå ERROR!
```

This built-in protection from Immer ensures that the immutable data flow is always respected, making your game more robust and predictable.
