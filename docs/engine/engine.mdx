import { Canvas, Meta, Source, Story } from '@storybook/addon-docs/blocks'
import * as Engine from './engine.stories'

import bounds from './bounds?raw'
import codeReuse from './code-reuse?raw'
import eventHandlers from './event-handlers?raw'
import framerate from './framerate?raw'

<Meta of={Engine} />

# Core Concepts

This page showcases some of the core concepts and features of the Inglorious Engine. If you are just getting started, we recommend you check out the [Quick Start Guide](/docs/quick-start--docs) first.

Inglorious Engine is a headless game engine that takes a configuration file in plain JavaScript and creates a scene. The UI can be implemented in any technology: canvas, HTML, ...here we are using React components.

Here are a few examples of what you can do.

## Bounds

We can customize the game's bounds by passing an array of four numbers: these will hold the upper and lower bounds in pixels.

The game is an entity in the game, that we can customize as we please.

<Source dark code={bounds} />

<Canvas of={Engine.Bounds} />

## Event Handlers

To animate stuff we write event handlers for events that are triggered by our entities or by the game itself. The `update` event, for example, is a special core event that is triggered at every cycle of the game loop.

An event handler accepts the following arguments:

- The `entity` itself that is handling the event, so we can change its properties to our needs;
- The triggered `event`, which contains a `payload` that holds whatever we need to accomplish our task;
- An `options` object that contains the following:
  - The elapsed time `dt`, which can help slow down certain movement algorithms based on the current FPS;
  - The game's current `config` object (here you can find the scene's `bounds`, for example);
  - All `entities` present in the scene; note that they are read-only, so look but don't touch!

You might notice the code directly changes properties on the `entity`. While this looks like a direct mutation, the engine uses [Immer](https://immerjs.github.io/immer/) under the hood. This allows you to write simple, mutable-style code while Immer handles the complexity of producing a new, immutable state object for you. It's the best of both worlds: simple code and the safety of immutability.

### Naming Conventions

The engine uses a simple and powerful naming convention for events to ensure clarity and prevent conflicts:

- **Core Engine Events are single words**: These are reserved, special-purpose commands like `update`, `add`, `remove`, and `morph`.
- **Custom Game Events are multi-word (`camelCase`)**: For all your game-specific logic, you should use descriptive, multi-word names like `playerJump`, `enemyTakeDamage`, or `itemCollect`.

This convention acts as a form of namespacing, similar to how custom HTML elements must contain a hyphen (e.g., `<my-component>`) to distinguish them from standard elements (e.g., `<div>`). It makes it immediately clear which events are part of the engine's lifecycle and which are specific to your game's logic.

The character shown here uses the `update` event to update its velocity and position at every frame, going back and forth like it's patroling the scene!

The `fps` type shows FPS debug info on the top left of the scene; its value is updated based on the `dt` time at every `update` event.

<Source dark code={eventHandlers} />

<Canvas of={Engine.EventHandlers} />

## Code Reuse

Coding is beautiful, but reusing code without reinventing the wheel is even better! This is where the engine's functional approach really shines through its **[Composition over Inheritance](/docs/engine-core-concepts-composition--docs)** philosophy.

Instead of relying on complex class inheritance hierarchies, we use **behavior composition**. A `type` is defined as an array of *behaviors*â€”plain JavaScript objects that contain event handlers. The engine merges these objects to create the final, composite behavior for the type.

This approach is more flexible and powerful than inheritance. You can mix and match behaviors by simply adding new objects to the type's array, avoiding problems like the "diamond problem" and creating deeply nested, brittle class structures.

The event handler for this character is also using a predefined `bounce()` function. There are many predefined functions out there at your disposal, just look through the documentation to find the ones that suit you best.

<Source dark code={codeReuse} />

<Canvas of={Engine.CodeReuse} />

## Dynamic Entities

A key advantage of building games in JavaScript is the language's inherent flexibility. Unlike in many statically-typed languages, JavaScript objects are dynamic. You can add, modify, or remove properties from any `entity` at runtime without needing to pre-define them in its `type`.

This is incredibly useful in game development. For example, if a character picks up a temporary power-up, you can simply attach a new property to the character's entity to manage its state.

### Example

Imagine an event handler for a collision between a player and a power-up item.

```javascript
// In a 'collision' event handler for the player entity...
entity.powerUp = { type: 'speed', duration: 10 }; // 10 seconds

// Later, in the 'game:update' event handler for the player...
if (entity.powerUp?.type === 'speed') {
    // This function would increase the player's speed
    // (Remember, Immer handles immutability for you!)
    entity.velocity[0] *= 1.5;
    entity.velocity[1] *= 1.5;

    entity.powerUp.duration -= dt;

    if (entity.powerUp.duration <= 0) {
        // Power-up has expired, remove the property.
        delete entity.powerUp;
    }
}
```

This approach allows for rapid prototyping and the creation of emergent game mechanics without being constrained by rigid class structures, which aligns perfectly with the engine's data-oriented and functional philosophy.

## Dynamic Types

While adding properties to individual entities at runtime is powerful for temporary state changes, sometimes you need to fundamentally alter the behavior of all entities of a certain type. The engine supports this through the `morph` event.

This allows you to redefine a type's decorators and event handlers on the fly. This is particularly useful for implementing mechanics like character evolution or complex power-up systems where the core behaviors of a character change.

### Example: Mario's Power-Ups

Let's revisit the classic Super Mario example. When Mario picks up a power-up, his abilities change. Instead of managing boolean flags on the entity (`canBreakBricks`, `canShootFire`), we can dynamically change the `mario` type itself.

Here's how you might dispatch a `morph` event upon collision with a Fire Flower:

```javascript
// In a collision event handler for Mario...
if (collidesWith(mario, fireFlower)) {
    notify("morph", {
        id: 'mario', // The ID of the type to change
        type: [ // The new array of behaviors and handlers
            baseMario(),
            superMario(),
            fireMario(),
            // ... other base behaviors like controls, physics etc.
        ],
    });
    // remove the power-up from the scene
    notify("remove", fireFlower.id);
}
```

When the engine processes this event, it will replace the existing definition for the `mario` type with the new one. All existing and future entities of `type: 'mario'` will now use the new set of behaviors, including the abilities from `fireMario()`.

This pattern keeps entity objects clean and centralizes behavior logic within type definitions, making your game architecture more robust and easier to reason about. You can see a complete implementation of this pattern in the Mario Power-Ups recipe.

## Performance Considerations

### The Myth of Slow Immutability

A common concern with immutable architectures is the perceived overhead of creating a new state object for every single change. In practice, this is a misconception.

Inglorious Engine uses modern techniques (specifically, the Immer library) to implement **structural sharing**. When you modify the state, only the parts of the data tree that are affected are actually copied. All other parts of the tree are shared by reference with the previous state.

This means that state updates are incredibly cheap and fast, regardless of the total size of your game state.

### The Benefit: Optimized Rendering

This immutable approach provides a major performance benefit, especially for rendering. To determine if a UI component needs to be rerendern, you can perform a simple and highly efficient reference equality check (`prevState.player === nextState.player`).

- If the reference is the same, the object hasn't changed, and no re-render is needed.
- If the reference is different, the object has changed, and it needs to be re-rendered.

This is orders of magnitude faster than the deep, recursive comparisons required to detect changes in a mutable state tree, and it's the secret behind the performance of modern web frameworks like React.

### Pragmatic Optimizations: Object Pooling

While immutability is the default and preferred approach, the engine's philosophy is pragmatic. For extremely high-frequency, short-lived objects (e.g., hundreds of bullets per second), the overhead of even fast immutable updates can add up.

In these specific, performance-critical scenarios, it's possible to manage a pool of mutable objects outside the main immutable state tree. This is an advanced pattern that provides an "escape hatch" for when raw performance is the absolute top priority, without compromising the stability and predictability of the rest of your game state. A dedicated object pooling system is planned for future versions to make this even easier.

## Fixed Framerate

What if you want to provide a more retro feel to your game? You can use a fixed framerate and make your animations more jerky by changing the default loop.

<Source dark code={framerate} />

<Canvas of={Engine.Framerate} />

## What's Next?

You've now seen the core features of the engine. Here's where you can go from here:

- **Add player controls**: See [Input Handling](/docs/engine-input--docs) for keyboard and mouse.
- **Detect collisions**: Learn about [Collision Detection](/docs/engine-collision-detection--docs).
- **Build autonomous characters**: Explore [AI Kinematic Movement](/docs/engine-ai-movement-kinematic--docs) and [AI Dynamic Movement](/docs/engine-ai-movement-dynamic--docs).
- **See complete examples**: Look at our [Recipes](/docs/engine-recipes--docs) for common game patterns.
- **Explore helper functions**: Check out the [Utilities](/docs/utils-docs--docs) available for common tasks.