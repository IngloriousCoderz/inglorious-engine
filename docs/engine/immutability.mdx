import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="Engine/Core Concepts/Immutability" />

# State Management and Immutability

The engine is built around a central principle: **the game state is immutable**. This concept, inspired by state management patterns like Redux, is crucial for writing predictable, maintainable, and easier-to-debug game logic.

## What is Immutability?

Immutability means that once a piece of data (like an entity's state) is created, it cannot be changed. If you need to update an entity, you don't modify the existing entity object. Instead, you create a *new* entity object with the updated properties. The engine's state manager then replaces the old entity with the new one.

This might sound inefficient, but the engine uses techniques to make this process fast. The benefits far outweigh the costs:

-   **Predictability:** State changes only happen in one way: by dispatching actions. This makes the data flow of your game unidirectional and easy to follow.
-   **Debugging:** Since data doesn't change unexpectedly, it's much easier to trace how and when your state updates. You can even implement features like time-travel debugging.
-   **Performance:** Immutability allows for cheap and fast equality checks. The engine can quickly determine if a piece of state has changed by simply checking if its reference has changed (`oldEntity === newEntity`). This is fundamental for performance optimizations like memoized selectors.

## The Read-Only Guard: `devMode`

To help you adhere to the principle of immutability, the engine provides a `devMode` flag. We strongly recommend enabling it during development.

When `devMode` is enabled, any entity you retrieve from the API via `api.getEntity()` or `api.getEntities()` is wrapped in a special read-only guard. If you accidentally try to mutate one of these entities directly, the engine will throw a descriptive error.

For example, this code will fail in `devMode`:

```javascript
// This is incorrect and will throw an error in devMode!
const player = api.getEntity("player");
player.position.x = 100; // ERROR: Cannot set property "position.x" on entity "player".
```

The error message guides you to the correct approach: notifying of an event to update the state.

```javascript
// This is the correct way to update state
api.notify("playerMove", { x: 100 });
```

**Important Note:**  While `devMode` prevents direct mutation when you retrieve entities, keep in mind that within your event handlers (functions with the signature `eventName(entity, eventPayload, api) {}`), the `entity` can still be mutated. In fact, it *appears* mutable because the engine uses Immer under the hood. However, you should still treat any other entities retrieved through `api.getEntity()` or `api.getEntities()` as immutable and avoid direct modifications. Always use `api.notify()` to dispatch actions that update their state.

Directly mutating entities in event handlers can lead to unexpected behavior and make debugging difficult, negating the benefits of immutability.

```

## How to Enable `devMode`

You can enable `devMode` in your main game configuration file when you initialize the engine.

```javascript
// In your game.js file
export default {
  devMode: true, // Enable the read-only guard
  // ... other configurations
  entities: {
    // ... your entities
  },
  types: {
    // ... your types and their event handlers
  }
}
```

By enabling `devMode`, you can catch common bugs early and ensure your game logic follows a clean, predictable pattern. This feature has no performance cost in production builds, as the guards are only active when `devMode` is `true`.
