import { Meta } from '@storybook/addon-docs/blocks'

<Meta title="Engine/Core Concepts/Composition" />

# Composition over Inheritance

A core philosophy of Inglorious Engine is favoring **composition over inheritance**. This is a common principle in software design, but the engine embraces it in a way that is particularly suited for the dynamic and stateful nature of games.

## The Problem: Changing Behavior

In many games, a character's abilities can change dramatically. A hero picks up a power-up, a vehicle gets an upgrade, or an enemy enters a different phase.

Traditional Object-Oriented Programming often models this with inheritance hierarchies or complex state machines. As shown in the [Super Mario Power-Ups recipe](/docs/engine-recipes--docs#super-mario-power-ups), these approaches can become rigid or lead to a lot of boilerplate code.

-   **Inheritance:** What happens when you need to combine behaviors from different branches of the inheritance tree (the "Diamond Problem")? How do you "downgrade" a character?
-   **State Pattern:** While flexible, it can lead to an explosion of small state classes to represent every possible combination of abilities.

## The Engine's Solution: Functional Composition

Inglorious Engine takes a different approach, inspired by functional programming and data-oriented design.

### 1. Entities are Just Data

An entity (like the player or an enemy) is fundamentally just a "bag of data"—a plain JavaScript object. It holds state (like `position`, `health`, `maxSpeed`) but has no methods.

```javascript
const mario = {
  id: "player",
  type: "mario",
  position: [50, 100, 0],
  maxSpeed: 250,
  // ... other data properties
}
```

### 2. Behaviors are Just Functions

All logic lives in functions, which are grouped into "behavior objects". These objects are essentially collections of event handlers.

To make behaviors configurable and reusable, we often create them with **behavior factories**—functions that return a behavior object.

```javascript
// A behavior for shooting fireballs
const firePower = { // This one is a simple object
  inputPress(entity, { action }) {
    if (action === 'shoot') {
      console.log('Shoot!');
    }
  }
}

// A behavior factory for jumping
function jumpable(params) { // This allows for custom parameters
  return {
    inputPress(entity, event, api) { /* ... */ },
    update(entity, dt, api) { /* ... */ },
  }
}
```

### 3. Types are Composed Behavior Arrays

This is the key insight. An entity's `type` is not a rigid class, but a dynamic **array of behavior objects**.

When an event occurs for an entity, the engine iterates through its type's behavior array and executes any matching event handlers it finds.

```javascript
// The type definition for a base mario
types: {
  mario: [
    { render: renderMario },   // A renderer object
    firePower,                 // A behavior object
    jumpable({ maxJumps: 2 }), // A behavior from a factory
  ],
}
```

### 4. Chaining Behaviors

A powerful feature of this composition model is the ability for behaviors to wrap and extend the logic of previously defined behaviors. A behavior factory doesn't just have to return a static object; it can be a higher-order function that receives the already-composed `type` and extends it.

This allows you to create decorators that chain their logic, similar to middleware.

```javascript
// A behavior factory that clamps the entity to the screen bounds
export function clamped() {
  // This function receives the type composed so far
  return (type) =>
    // It returns a new, extended behavior object
    extend(type, {
      // It defines its own update handler
      update(entity, dt, api) {
        // Crucially, it calls the original update handler first
        type.update?.(entity, dt, api)

        // Then, it adds its own logic
        const game = api.getEntity("game")
        merge(entity, { position: clampToBounds(entity, game.bounds) })
      },
    })
}
```

### 5. Runtime Re-Composition

Because a `type` is just an array, we can change it at any time. By dispatching a `morph` event, you can provide a completely new array of behaviors for an entity type. This is how we achieve the "Decorator Pattern" in a functional way.

When Mario picks up a Fire Flower, we don't just set a flag. We fundamentally change what he *can do* by recomposing his behavior array. See the full implementation in the [Super Mario Power-Ups recipe](/docs/engine-recipes--docs#super-mario-power-ups).

This approach provides incredible flexibility:
-   **No "Diamond Problem":** You can mix and match any behaviors you want. An "Ultra Mario" with fire and flight is just `[...base, firePower, capePower]`.
-   **Dynamic & Pluggable:** You can add or remove behaviors at any point in the game's lifecycle. You could even load new behavior modules from a server and plug them into an existing entity type.
-   **Clear & Testable:** Each behavior is a self-contained unit that can be tested in isolation.